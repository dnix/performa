"""Tests for the CashFlowAnalysis class and related analysis logic."""
from datetime import date

import pandas as pd
import pytest

from performa.asset._absorption import (
    AbsorptionPlan,
    DirectLeaseTerms,
    FixedQuantityPace,
    SpaceFilter,
    StartDateAnchorEnum,
)

# Import models needed for testing
from performa.asset._analysis import CashFlowAnalysis
from performa.asset._lease import LeaseSpec
from performa.asset._losses import GeneralVacancyLossConfig, Losses
from performa.asset._property import Property
from performa.asset._rent_roll import RentRoll, VacantSuite
from performa.asset._rollover import RolloverLeaseTerms, RolloverProfile
from performa.core._enums import (
    AggregateLineKey,
    AssetTypeEnum,
    FrequencyEnum,
    LeaseTypeEnum,
    ProgramUseEnum,
    UnitOfMeasureEnum,
    UponExpirationEnum,
    VacancyLossMethodEnum,
)
from performa.core._settings import GlobalSettings

# --- Fixtures --- 

@pytest.fixture
def analysis_fixture():
    """Fixture for setting up CashFlowAnalysis tests with LeaseSpec inputs."""
    
    # Profile 1: 2 months downtime
    market_terms1 = RolloverLeaseTerms(
        market_rent=50.0, # rent_psf becomes market_rent
        unit_of_measure=UnitOfMeasureEnum.PER_UNIT, # PSF becomes PER_UNIT
        frequency=FrequencyEnum.ANNUAL # Assuming annual rate for 50.0
        # months_vacant is a characteristic of RolloverProfile, not these terms.
        # term_months for the lease generated by these terms is defined in RolloverProfile.
    )
    profile1 = RolloverProfile(
        name="Market Rollover 2mo Vac", 
        upon_expiration=UponExpirationEnum.VACATE, 
        downtime_months=2, # Changed months_vacant to downtime_months
        market_terms=market_terms1,
        term_months=36, # This is where term_months for the profile belongs
        renewal_probability=0.0,
        renewal_terms=market_terms1.model_copy(), # Use model_copy for safety
        option_terms=market_terms1.model_copy()   # Use model_copy for safety
    )
    
    # LeaseSpec 1 (instead of Lease)
    lease_spec1 = LeaseSpec(
        tenant_name="Tenant 1", suite="101", floor="1", 
        use_type=ProgramUseEnum.OFFICE, lease_type=LeaseTypeEnum.NET, # Changed NNN to NET
        area=1000,
        start_date=date(2024, 1, 1), end_date=date(2024, 12, 31), 
        base_rent_value=48.0, base_rent_unit_of_measure=UnitOfMeasureEnum.PER_UNIT, # Changed PSF
        base_rent_frequency=FrequencyEnum.ANNUAL,
        upon_expiration=UponExpirationEnum.VACATE,
        rollover_profile_ref=profile1.name, 
        source="Input" 
    )

    # Profile 2: 4 months downtime
    market_terms2 = RolloverLeaseTerms(
        market_rent=55.0,
        unit_of_measure=UnitOfMeasureEnum.PER_UNIT,
        frequency=FrequencyEnum.ANNUAL
    )
    profile2 = RolloverProfile(
        name="Market Rollover 4mo Vac", 
        upon_expiration=UponExpirationEnum.MARKET,
        downtime_months=4, # Changed months_vacant to downtime_months
        market_terms=market_terms2,
        term_months=60, 
        renewal_probability=0.0,
        renewal_terms=market_terms2.model_copy(),
        option_terms=market_terms2.model_copy()
    )
    
    # LeaseSpec 2
    lease_spec2 = LeaseSpec(
        tenant_name="Tenant 2", suite="102", floor="1", 
        use_type=ProgramUseEnum.OFFICE, lease_type=LeaseTypeEnum.NET, # Changed NNN to NET
        area=1500,
        start_date=date(2024, 6, 1), end_date=date(2025, 5, 31), 
        base_rent_value=50.0, base_rent_unit_of_measure=UnitOfMeasureEnum.PER_UNIT, # Changed PSF
        base_rent_frequency=FrequencyEnum.ANNUAL,
        upon_expiration=UponExpirationEnum.MARKET,
        rollover_profile_ref=profile2.name, 
        source="Input"
    )
    
    # Property Setup
    rent_roll = RentRoll(leases=[lease_spec1, lease_spec2], vacant_suites=[]) # Use LeaseSpec list
    prop = Property(
        name="Analysis Test Prop", property_type="Office", net_rentable_area=2500,
        rent_roll=rent_roll,
        rollover_profiles=[profile1, profile2], # Add profiles to Property
        losses=Losses(
            general_vacancy=GeneralVacancyLossConfig(rate=0.05, method=VacancyLossMethodEnum.POTENTIAL_GROSS_REVENUE),
            collection_loss=None # Keep as None as per original fixture
        ),
        address="123 Test St", geography="Test", submarket="Test", market="Test", year_built=2010
    )

    # Analysis Setup
    analysis_start = date(2024, 1, 1)
    analysis_end = date(2026, 12, 31) 
    analyzer = CashFlowAnalysis( # Renamed 'analysis' to 'analyzer' for clarity
        property=prop, 
        analysis_start_date=analysis_start, 
        analysis_end_date=analysis_end
    )
    
    # Mock the lookup_fn on the analyzer instance
    profile_map_for_lookup = {p.name: p for p in prop.rollover_profiles or []} 
    
    def _mock_lookup(key_to_lookup):
        if isinstance(key_to_lookup, str):
            if key_to_lookup in profile_map_for_lookup:
                return profile_map_for_lookup[key_to_lookup]
            if hasattr(prop, key_to_lookup):
                val = getattr(prop, key_to_lookup)
                if isinstance(val, (int, float, str, date)): 
                    return val
        raise LookupError(f"Test mock lookup failed for key: {key_to_lookup}")

    analyzer._build_lookup_fn = lambda computed_results_map_arg: _mock_lookup

    return analyzer, lease_spec1, lease_spec2

# --- Tests for Rollover Vacancy Aggregation --- 
# Renamed from test_get_projected_leases_aggregates_rollover_loss
def test_rollover_vacancy_aggregation(analysis_fixture):
    """Test that rollover vacancy loss is correctly aggregated by CashFlowAnalysis."""
    analyzer, lease_spec1, lease_spec2 = analysis_fixture
    analysis_periods = analyzer._create_timeline().period_index
    
    # --- Expected Loss Calculation (remains similar, uses lease_spec areas) --- 
    # Lease 1 (spec1): Ends 2024-12-31, profile1 has 2 months vacant (Jan, Feb 2025), Market Rent $50/yr
    # Profile is taken from the property, which was set up in the fixture
    profile1 = analyzer.property.rollover_profiles[0] # Assumes order in fixture
    market_rent1_monthly = profile1.market_terms.rent_psf / 12 
    loss1_monthly = market_rent1_monthly * lease_spec1.area 
    expected_loss1 = pd.Series(loss1_monthly, index=pd.period_range("2025-01", "2025-02", freq='M'))
    
    # Lease 2 (spec2): Ends 2025-05-31, profile2 has 4 months vacant (Jun, Jul, Aug, Sep 2025), Market Rent $55/yr
    profile2 = analyzer.property.rollover_profiles[1] # Assumes order in fixture
    market_rent2_monthly = profile2.market_terms.rent_psf / 12
    loss2_monthly = market_rent2_monthly * lease_spec2.area
    expected_loss2 = pd.Series(loss2_monthly, index=pd.period_range("2025-06", "2025-09", freq='M'))

    # Combined expected loss
    expected_total_rollover_loss = pd.Series(0.0, index=analysis_periods)
    expected_total_rollover_loss = expected_total_rollover_loss.add(expected_loss1.reindex(analysis_periods, fill_value=0.0), fill_value=0.0)
    expected_total_rollover_loss = expected_total_rollover_loss.add(expected_loss2.reindex(analysis_periods, fill_value=0.0), fill_value=0.0)
    # --- End Expected Loss Calculation --- 

    # --- Execute --- 
    # Trigger full calculation and get aggregated flows
    # Calling _get_aggregated_flows will trigger _compute_detailed_flows internally
    aggregated_flows = analyzer._get_aggregated_flows() 
    actual_rollover_loss_series = aggregated_flows.get(AggregateLineKey.ROLLOVER_VACANCY_LOSS)
    # --- End Execute --- 
    
    # --- Assertions --- 
    assert actual_rollover_loss_series is not None, "ROLLOVER_VACANCY_LOSS key missing from aggregated_flows"
    pd.testing.assert_series_equal(actual_rollover_loss_series, expected_total_rollover_loss, check_names=False)
    
    # Check specific periods
    assert actual_rollover_loss_series['2025-01'] == pytest.approx(loss1_monthly)
    assert actual_rollover_loss_series['2025-02'] == pytest.approx(loss1_monthly)
    assert actual_rollover_loss_series['2025-03'] == 0.0 # Lease 1 market term starts
    assert actual_rollover_loss_series['2025-06'] == pytest.approx(loss2_monthly)
    assert actual_rollover_loss_series['2025-09'] == pytest.approx(loss2_monthly)
    assert actual_rollover_loss_series['2025-10'] == 0.0 # Lease 2 market term starts

# --- Tests for _aggregate_detailed_flows Vacancy Reduction Logic --- 

def test_aggregate_flows_vacancy_reduction_enabled(analysis_fixture):
    """Test general vacancy is reduced by rollover loss and downtime loss when flag is True."""
    # --- SETUP --- #
    analyzer, fixture_lease_spec1, fixture_lease_spec2 = analysis_fixture # Get analyzer and original specs
    
    # Ensure reduction flag is True
    analyzer.property.losses.general_vacancy.reduce_general_vacancy_by_rollover_vacancy = True
    
    # Add a future-starting LeaseSpec to generate downtime loss for this specific test
    future_lease_spec_for_downtime = LeaseSpec(
        tenant_name="Future Tenant For Downtime Test", suite="201", floor="2", area=2000,
        use_type=ProgramUseEnum.OFFICE, lease_type=LeaseTypeEnum.NET,
        start_date=date(2025, 4, 1), # Starts Apr 2025 (Analysis starts Jan 2025)
        term_months=60,
        base_rent_value=36.0, base_rent_unit_of_measure=UnitOfMeasureEnum.PER_UNIT,
        base_rent_frequency=FrequencyEnum.ANNUAL,
        upon_expiration=UponExpirationEnum.MARKET, 
        rollover_profile_ref="Market Rollover 2mo Vac", # Reuse a profile from fixture
        source="Input"
    )
    # IMPORTANT: Modify a copy of the rent roll leases list from the property
    current_input_specs = list(analyzer.property.rent_roll.leases) # Make a copy
    current_input_specs.append(future_lease_spec_for_downtime)
    analyzer.property.rent_roll.leases = current_input_specs # Assign updated list
    analyzer.property.net_rentable_area += future_lease_spec_for_downtime.area # Update NRA
    
    # Clear caches as property has changed for this test case
    analyzer._cached_initial_lease_objects = None
    analyzer._cached_detailed_flows = None
    analyzer._cached_aggregated_flows = None
    analyzer._cached_occupancy_series = None

    analysis_periods = analyzer._create_timeline().period_index

    # --- EXPECTED VALUES --- #
    # 1. Calculate Expected PGR from all lease specs (fixture + added future one)
    analyzer._compute_detailed_flows() # This populates _cached_detailed_flows
    detailed_flows = analyzer._cached_detailed_flows
    pgr_series = pd.Series(0.0, index=analysis_periods)
    if detailed_flows:
        for meta, series in detailed_flows:
            if meta["category"] == "Revenue" and meta["component"] == "base_rent":
                pgr_series = pgr_series.add(series.reindex(analysis_periods, fill_value=0.0), fill_value=0.0)

    # 2. Get Expected Rollover Loss and Downtime Loss from the aggregated results
    #    These are what the general vacancy reduction logic will actually use.
    aggregated_flows_for_expected_calc = analyzer._get_aggregated_flows()
    expected_rollover_loss = aggregated_flows_for_expected_calc.get(AggregateLineKey.ROLLOVER_VACANCY_LOSS, pd.Series(0.0, index=analysis_periods))
    expected_downtime_loss_from_agg = aggregated_flows_for_expected_calc.get(AggregateLineKey.DOWNTIME_VACANCY_LOSS, pd.Series(0.0, index=analysis_periods))

    # 3. Combined Specific Loss
    expected_specific_loss = expected_rollover_loss.add(expected_downtime_loss_from_agg, fill_value=0.0)

    # 4. Expected Gross General Vacancy
    vacancy_rate = analyzer.property.losses.general_vacancy.rate
    expected_gross_vacancy = pgr_series * vacancy_rate

    # 5. Calculate expected Net General Vacancy (Reduction applied)
    expected_net_vacancy = (expected_gross_vacancy - expected_specific_loss).clip(lower=0)
    # --- End Expected Values Calculation --- 

    # --- EXECUTE (already done to get aggregated_flows_for_expected_calc) --- 
    final_aggregated_flows = aggregated_flows_for_expected_calc

    # --- ASSERTIONS --- 
    # A. Check that the DOWNTIME_VACANCY_LOSS line item is calculated as expected for the added lease
    manual_expected_downtime_monthly = (future_lease_spec_for_downtime.area * 36.0 / 12)
    manual_expected_downtime_series = pd.Series(0.0, index=analysis_periods)
    # Downtime for future_lease_spec_for_downtime: Jan 2025 - Mar 2025
    downtime_periods_for_future_lease = pd.period_range("2025-01", "2025-03", freq='M')
    manual_expected_downtime_series.loc[downtime_periods_for_future_lease] = manual_expected_downtime_monthly
    pd.testing.assert_series_equal(expected_downtime_loss_from_agg, manual_expected_downtime_series, check_names=False, rtol=1e-5)

    # B. Check the final GENERAL_VACANCY_LOSS line item reflects reduction by *combined* specific loss
    final_general_vacancy_loss = final_aggregated_flows.get(AggregateLineKey.GENERAL_VACANCY_LOSS)
    assert final_general_vacancy_loss is not None
    pd.testing.assert_series_equal(final_general_vacancy_loss, expected_net_vacancy, check_names=False, rtol=1e-5)

    # C. Verify specific periods for reduction logic
    # Jan 2025: Should have rollover from fixture_lease_spec1 and downtime from future_lease_spec_for_downtime
    # Expected rollover for lease_spec1 in Jan 2025:
    profile1_for_calc = analyzer.property.rollover_profiles[0]
    loss1_monthly_jan25 = (profile1_for_calc.market_terms.rent_psf / 12) * fixture_lease_spec1.area
    
    specific_loss_jan25 = loss1_monthly_jan25 + manual_expected_downtime_monthly
    assert expected_specific_loss['2025-01'] == pytest.approx(specific_loss_jan25)
    assert final_general_vacancy_loss['2025-01'] == pytest.approx(max(0, expected_gross_vacancy['2025-01'] - specific_loss_jan25))
    
    # Apr 2025: No Rollover from fixture leases, No Downtime (future_lease_spec_for_downtime starts)
    assert expected_specific_loss['2025-04'] == 0.0
    assert final_general_vacancy_loss['2025-04'] == pytest.approx(expected_gross_vacancy['2025-04'])

def test_aggregate_flows_vacancy_reduction_disabled(analysis_fixture):
    """Test general vacancy equals gross vacancy when reduction flag is False."""
    analyzer, _, _ = analysis_fixture
    # --- Setup: Ensure reduction flag is False --- 
    analyzer.property.losses.general_vacancy.reduce_general_vacancy_by_rollover_vacancy = False
    analysis_periods = analyzer._create_timeline().period_index

    # --- Calculation of Expected Values --- 
    # 1. Calculate expected Potential Gross Revenue (PGR) using the new flow
    analyzer._compute_detailed_flows() # This populates _cached_detailed_flows
    detailed_flows = analyzer._cached_detailed_flows
    pgr_series = pd.Series(0.0, index=analysis_periods)
    if detailed_flows:
        for meta, series in detailed_flows:
            if meta["category"] == "Revenue" and meta["component"] == "base_rent":
                pgr_series = pgr_series.add(series.reindex(analysis_periods, fill_value=0.0), fill_value=0.0)
    
    # 2. Calculate expected Gross General Vacancy
    vacancy_rate = analyzer.property.losses.general_vacancy.rate
    expected_gross_vacancy = pgr_series * vacancy_rate
    # --- End Expected Values Calculation --- 

    # --- Execute Aggregation --- 
    # _compute_detailed_flows was called above; _get_aggregated_flows uses its cached result.
    aggregated_flows = analyzer._get_aggregated_flows()
    # --- End Execution --- 

    # --- Assertions --- 
    final_vacancy_loss = aggregated_flows.get(AggregateLineKey.GENERAL_VACANCY_LOSS)
    assert final_vacancy_loss is not None
    # Should equal gross vacancy when disabled
    pd.testing.assert_series_equal(final_vacancy_loss, expected_gross_vacancy, check_names=False)

def test_aggregate_flows_vacancy_reduction_edge_case(analysis_fixture):
    """Test reduction when specific rollover loss exceeds gross vacancy (net should be 0)."""
    analyzer, lease_spec1, lease_spec2 = analysis_fixture
    # --- Setup: Ensure reduction flag is True and Vacancy Rate is Low --- 
    analyzer.property.losses.general_vacancy.reduce_general_vacancy_by_rollover_vacancy = True
    analyzer.property.losses.general_vacancy.rate = 0.01 # Very low vacancy rate
    analysis_periods = analyzer._create_timeline().period_index

    # --- Calculation of Expected Values --- 
    # 1. Calculate PGR
    analyzer._compute_detailed_flows()
    detailed_flows = analyzer._cached_detailed_flows
    pgr_series = pd.Series(0.0, index=analysis_periods)
    if detailed_flows:
        for meta, series in detailed_flows:
            if meta["category"] == "Revenue" and meta["component"] == "base_rent":
                pgr_series = pgr_series.add(series.reindex(analysis_periods, fill_value=0.0), fill_value=0.0)

    # 2. Get Rollover Loss from aggregated results (as this is what reduction logic uses)
    aggregated_flows_for_expected_calc = analyzer._get_aggregated_flows()
    expected_rollover_loss = aggregated_flows_for_expected_calc.get(AggregateLineKey.ROLLOVER_VACANCY_LOSS, pd.Series(0.0, index=analysis_periods))
    # For this test, we assume no downtime loss from the base fixture setup
    expected_downtime_loss = pd.Series(0.0, index=analysis_periods)
    expected_specific_loss = expected_rollover_loss.add(expected_downtime_loss, fill_value=0.0)

    # 3. Calculate expected Gross General Vacancy
    vacancy_rate = analyzer.property.losses.general_vacancy.rate
    expected_gross_vacancy = pgr_series * vacancy_rate
    
    # 4. Expected net is clipped at zero
    expected_net_vacancy = (expected_gross_vacancy - expected_specific_loss).clip(lower=0)
    # --- End Expected Values Calculation --- 

    # --- Execute Aggregation --- 
    # Aggregation already happened to get temp_aggregated_flows
    aggregated_flows = aggregated_flows_for_expected_calc 
    # --- End Execution --- 

    # --- Assertions --- 
    final_vacancy_loss = aggregated_flows.get(AggregateLineKey.GENERAL_VACANCY_LOSS)
    assert final_vacancy_loss is not None
    pd.testing.assert_series_equal(final_vacancy_loss, expected_net_vacancy, check_names=False)

    # Check a period where rollover loss definitely exceeds gross loss
    period_with_high_rollover = '2025-06' # Lease 2 rollover loss occurs here
    # We need the actual specific loss for this period to compare with gross general vacancy
    if not expected_rollover_loss.empty and period_with_high_rollover in expected_rollover_loss.index:
        assert expected_rollover_loss[period_with_high_rollover] > expected_gross_vacancy[period_with_high_rollover]
    assert final_vacancy_loss[period_with_high_rollover] == 0.0 # Should be clipped to zero

def test_aggregate_flows_vacancy_reduction_egr_basis(analysis_fixture):
    """Test vacancy reduction logic when the basis is Effective Gross Revenue (EGR)."""
    analyzer, _, _ = analysis_fixture
    # --- Setup: Ensure reduction flag is True and basis is EGR --- 
    analyzer.property.losses.general_vacancy.reduce_general_vacancy_by_rollover_vacancy = True
    analyzer.property.losses.general_vacancy.method = VacancyLossMethodEnum.EFFECTIVE_GROSS_REVENUE
    analysis_periods = analyzer._create_timeline().period_index

    # --- Calculation of Expected Values --- 
    # 1. Calculate intermediate aggregate lines needed for EGR basis
    analyzer._compute_detailed_flows()
    # Get all necessary series from the initial aggregation pass
    temp_aggregated_flows = analyzer._get_aggregated_flows() 
    
    pgr_series_from_agg = temp_aggregated_flows.get(AggregateLineKey.POTENTIAL_GROSS_REVENUE, pd.Series(0.0, index=analysis_periods))
    misc_series_from_agg = temp_aggregated_flows.get(AggregateLineKey.MISCELLANEOUS_INCOME, pd.Series(0.0, index=analysis_periods))
    abate_series_from_agg = temp_aggregated_flows.get(AggregateLineKey.RENTAL_ABATEMENT, pd.Series(0.0, index=analysis_periods))
    expected_rollover_loss = temp_aggregated_flows.get(AggregateLineKey.ROLLOVER_VACANCY_LOSS, pd.Series(0.0, index=analysis_periods))
    expected_downtime_loss = temp_aggregated_flows.get(AggregateLineKey.DOWNTIME_VACANCY_LOSS, pd.Series(0.0, index=analysis_periods))
    expected_specific_loss = expected_rollover_loss.add(expected_downtime_loss, fill_value=0.0)

    # 2. Calculate EGR basis (PGR + Misc - Abatement) as it would be *before* general vacancy
    egr_basis_series = pgr_series_from_agg.add(misc_series_from_agg, fill_value=0.0).sub(abate_series_from_agg, fill_value=0.0)

    # 3. Calculate expected Gross General Vacancy based on EGR basis
    vacancy_rate = analyzer.property.losses.general_vacancy.rate
    expected_gross_vacancy = egr_basis_series * vacancy_rate

    # 4. Calculate expected Net General Vacancy
    expected_net_vacancy = (expected_gross_vacancy - expected_specific_loss).clip(lower=0)
    # --- End Expected Values Calculation --- 

    # --- Execute Aggregation --- 
    # Aggregation already happened to get temp_aggregated_flows
    aggregated_flows = temp_aggregated_flows
    # --- End Execution --- 

    # --- Assertions --- 
    final_vacancy_loss = aggregated_flows.get(AggregateLineKey.GENERAL_VACANCY_LOSS)
    assert final_vacancy_loss is not None
    # Check the final loss matches the net calculation based on EGR
    pd.testing.assert_series_equal(final_vacancy_loss, expected_net_vacancy, check_names=False)

# --- Integration Tests for CashFlowAnalysis --- #

# Remove skip marker
# @pytest.mark.skip(reason="Requires full setup and fixture implementation")
def test_cash_flow_analysis_with_absorption(global_settings_default): # Use fixture
    """Integration test for CashFlowAnalysis including an AbsorptionPlan."""
    # Arrange
    # 1. Define Analysis Period & Settings
    analysis_start = date(2025, 1, 1)
    analysis_end = date(2026, 12, 31)
    settings = global_settings_default

    # 2. Define Vacant Suites
    vacant_suites = [
        VacantSuite(suite="VAC-1", floor="1", area=10000, use_type=ProgramUseEnum.OFFICE)
    ]

    # 3. Define Input Lease Specs
    input_lease_specs = [
        LeaseSpec(
            tenant_name="Existing Tenant", suite="101", floor="1", area=5000,
            use_type=ProgramUseEnum.OFFICE, lease_type=LeaseTypeEnum.NET,
            start_date=date(2024, 1, 1), end_date=date(2025, 12, 31),
            base_rent_value=30.0, base_rent_unit_of_measure=UnitOfMeasureEnum.PER_UNIT,
            frequency=FrequencyEnum.ANNUAL,
            upon_expiration=UponExpirationEnum.MARKET, rollover_profile_ref="StdOfficeProfile",
            source="Input"
        ),
        LeaseSpec(
            tenant_name="Future Tenant VacInc", suite="102", floor="1", area=6000,
            use_type=ProgramUseEnum.OFFICE, lease_type=LeaseTypeEnum.NET,
            start_date=date(2025, 7, 1), term_months=60,
            base_rent_value=32.0, base_rent_unit_of_measure=UnitOfMeasureEnum.PER_UNIT,
            frequency=FrequencyEnum.ANNUAL,
            upon_expiration=UponExpirationEnum.MARKET, rollover_profile_ref="StdOfficeProfile",
            source="Input"
        ),
    ]

    # 4. Define RentRoll
    rent_roll = RentRoll(leases=input_lease_specs, vacant_suites=vacant_suites)

    # 5. Define Expenses (Keep None for simplicity in this test)
    expenses = None

    # 6. Define Rollover Profile (Concrete Simple Instance)
    # Simple market terms for the profile
    class MockRLT(RolloverLeaseTerms):
        # Mock method needed for fallback rent calculation
        def _calculate_rent(self, term_config, rollover_date, global_settings):
            return 40.0 # Market rent for profile
    
    mock_market_terms = MockRLT(
        term_months=60,
        base_rent_value=None, # Rent calculated
        unit_of_measure=UnitOfMeasureEnum.PER_UNIT,
        frequency=FrequencyEnum.ANNUAL,
        upon_expiration=UponExpirationEnum.MARKET # upon_exp for the *next* term
    )
    mock_profile = RolloverProfile(
        name="StdOfficeProfile",
        term_months=60, # Matches market terms
        renewal_probability=0.0,
        downtime_months=3,
        market_terms=mock_market_terms,
        renewal_terms=mock_market_terms, # Dummy
        option_terms=mock_market_terms   # Dummy
    )
    rollover_profiles = [mock_profile]
    profile_map = {mock_profile.name: mock_profile} # Map for lookup

    # 7. Define Absorption Plan
    absorption_plan = AbsorptionPlan(
        name="MainOfficeAbsorption",
        space_filter=SpaceFilter(use_types=[ProgramUseEnum.OFFICE]),
        start_date_anchor=StartDateAnchorEnum.ANALYSIS_START,
        pace=FixedQuantityPace(quantity=1, unit="Units", frequency_months=1),
        leasing_assumptions=mock_profile.name # Reference profile by name
    )

    # 8. Create Property
    prop = Property(
        name="Test Property Absorb",
        property_type="Office",
        net_rentable_area = sum(ls.area for ls in input_lease_specs) + sum(vs.area for vs in vacant_suites),
        gross_area=sum(ls.area for ls in input_lease_specs) + 1000, # Example, provide if needed or None
        rent_roll=rent_roll,
        expenses=expenses,
        rollover_profiles=rollover_profiles,
        losses=Losses(general_vacancy=GeneralVacancyLossConfig(rate=0.05)) # Add default losses
    )

    # 9. Instantiate CashFlowAnalysis
    analyzer = CashFlowAnalysis(
        property=prop,
        analysis_start_date=analysis_start,
        analysis_end_date=analysis_end,
        settings=settings,
        absorption_plans=[absorption_plan]
    )

    # --- Mock lookup function --- #
    # This needs to be robust enough for profile lookups
    # and potentially attribute lookups if CashFlowModel.reference uses strings
    def mock_lookup(key):
        if isinstance(key, str):
            if key == mock_profile.name:
                return mock_profile
            if hasattr(prop, key):
                 val = getattr(prop, key)
                 if isinstance(val, (int, float, str, date)): return val
        # Add more lookup logic here if needed for other tests
        raise LookupError(f"Mock lookup failed for key: {key}")
    analyzer._build_lookup_fn = lambda computed_results: mock_lookup

    # Act
    summary_df = analyzer.create_cash_flow_dataframe()
    detailed_df = analyzer.create_detailed_cash_flow_dataframe()

    # Assert
    assert isinstance(summary_df, pd.DataFrame)
    assert not summary_df.empty
    expected_periods = pd.period_range(start=analysis_start, end=analysis_end, freq="M")
    pd.testing.assert_index_equal(summary_df.index, expected_periods)

    # --- Specific Assertions --- #
    pgr_col = AggregateLineKey.POTENTIAL_GROSS_REVENUE.value
    assert pgr_col in summary_df.columns

    # Expected Rents per Month (approx)
    rent_existing = 5000 * 30.0 / 12 # 12500
    rent_future = 6000 * 32.0 / 12   # 16000
    rent_absorbed = 10000 * 40.0 / 12 # 33333.33 (using profile rent)

    # Check Jan 2025: Existing + Absorbed VAC-1
    assert summary_df[pgr_col].loc[pd.Period("2025-01", freq="M")] == pytest.approx(rent_existing + rent_absorbed)

    # Check Jul 2025: Existing + Absorbed VAC-1 + Future VacInc
    assert summary_df[pgr_col].loc[pd.Period("2025-07", freq="M")] == pytest.approx(rent_existing + rent_absorbed + rent_future)

    # Check Jan 2026: Absorbed VAC-1 + Future VacInc + Rollover of Existing Tenant
    # Existing tenant rolls 2026-01-01. Profile has 3 months downtime.
    # So, Jan 2026 should NOT include rent from the rolled lease (Suite 101)
    assert summary_df[pgr_col].loc[pd.Period("2026-01", freq="M")] == pytest.approx(rent_absorbed + rent_future)
    # Rolled lease (101) should start April 2026 (Jan+Feb+Mar downtime)
    # Rent would be market rate from profile (40.0/yr)
    rent_rolled_existing = 5000 * 40.0 / 12
    assert summary_df[pgr_col].loc[pd.Period("2026-04", freq="M")] == pytest.approx(rent_absorbed + rent_future + rent_rolled_existing)

    # Check Vacancy Loss
    vac_col = AggregateLineKey.GENERAL_VACANCY_LOSS.value
    assert vac_col in summary_df.columns
    # Rollover vacancy for suite 101 (5k SF * $40/yr) occurs Jan-Mar 2026
    expected_rollover_vac = (5000 * 40.0 / 12)
    # Gross general vacancy is 5% of PGR
    pgr_jan26 = rent_absorbed + rent_future
    gross_gen_vac_jan26 = pgr_jan26 * 0.05
    # Net general vacancy = max(0, Gross - Rollover)
    expected_net_vac_jan26 = max(0, gross_gen_vac_jan26 - expected_rollover_vac)
    assert summary_df[vac_col].loc[pd.Period("2026-01", freq="M")] == pytest.approx(expected_net_vac_jan26)
    assert summary_df[vac_col].loc[pd.Period("2026-02", freq="M")] == pytest.approx(expected_net_vac_jan26) # Approx same PGR
    assert summary_df[vac_col].loc[pd.Period("2026-03", freq="M")] == pytest.approx(expected_net_vac_jan26)
    # Apr 2026: No rollover loss, just general vacancy on full PGR
    pgr_apr26 = rent_absorbed + rent_future + rent_rolled_existing
    gross_gen_vac_apr26 = pgr_apr26 * 0.05
    assert summary_df[vac_col].loc[pd.Period("2026-04", freq="M")] == pytest.approx(gross_gen_vac_apr26)

    # --- Check Downtime Vacancy ---
    downtime_col = AggregateLineKey.DOWNTIME_VACANCY_LOSS.value
    assert downtime_col in summary_df.columns
    # Expected downtime from Future Tenant VacInc (6k SF * $32/yr) from Jan 2025 to Jun 2025
    expected_downtime_monthly = (6000 * 32.0 / 12) # 16000
    for month in range(1, 7): # Jan to Jun
        period = pd.Period(f"2025-{month:02d}", freq="M")
        assert summary_df[downtime_col].loc[period] == pytest.approx(expected_downtime_monthly)
    # July 2025 onwards should have zero downtime loss
    assert summary_df[downtime_col].loc[pd.Period("2025-07", freq="M")] == 0.0
    assert summary_df[downtime_col].loc[pd.Period("2026-01", freq="M")] == 0.0

    # --- Re-check General Vacancy Reduction (Jan 2026) - Including Downtime ---
    # General Vacancy reduction should consider *both* rollover and downtime loss
    # However, in Jan 2026, there is only Rollover Vacancy, no Downtime Vacancy
    # So the previous assertion for expected_net_vac_jan26 remains correct.
    # Let's check a period with Downtime Vacancy (e.g., Jan 2025)
    pgr_jan25 = rent_existing + rent_absorbed
    gross_gen_vac_jan25 = pgr_jan25 * 0.05
    rollover_loss_jan25 = 0.0 # No rollover loss this early
    downtime_loss_jan25 = expected_downtime_monthly
    specific_loss_jan25 = rollover_loss_jan25 + downtime_loss_jan25
    expected_net_vac_jan25 = max(0, gross_gen_vac_jan25 - specific_loss_jan25)
    assert summary_df[vac_col].loc[pd.Period("2025-01", freq="M")] == pytest.approx(expected_net_vac_jan25)

    # TODO: Add more assertions for NOI, UCF etc.
    noi_col = AggregateLineKey.NET_OPERATING_INCOME.value
    assert noi_col in summary_df.columns
    assert summary_df[noi_col].sum() != 0 # Basic check


def test_cash_flow_analysis_input_only(global_settings_default):
    """Integration test for CashFlowAnalysis with only input LeaseSpecs."""
    # Arrange
    analysis_start = date(2025, 1, 1)
    analysis_end = date(2026, 12, 31)
    settings = global_settings_default

    input_lease_specs = [
        LeaseSpec(
            tenant_name="Existing Tenant", suite="101", floor="1", area=5000,
            use_type=ProgramUseEnum.OFFICE, lease_type=LeaseTypeEnum.NET,
            start_date=date(2024, 1, 1), end_date=date(2025, 12, 31),
            base_rent_value=30.0, base_rent_unit_of_measure=UnitOfMeasureEnum.PER_UNIT,
            frequency=FrequencyEnum.ANNUAL,
            upon_expiration=UponExpirationEnum.MARKET, rollover_profile_ref="StdOfficeProfile",
            source="Input"
        ),
        LeaseSpec(
            tenant_name="Future Tenant VacInc", suite="102", floor="1", area=6000,
            use_type=ProgramUseEnum.OFFICE, lease_type=LeaseTypeEnum.NET,
            start_date=date(2025, 7, 1), term_months=60,
            base_rent_value=32.0, base_rent_unit_of_measure=UnitOfMeasureEnum.PER_UNIT,
            frequency=FrequencyEnum.ANNUAL,
            upon_expiration=UponExpirationEnum.MARKET, rollover_profile_ref="StdOfficeProfile",
            source="Input"
        ),
    ]
    rent_roll = RentRoll(leases=input_lease_specs, vacant_suites=[]) # No vacant suites
    
    # --- Reusable Rollover Profile Setup --- #
    class MockRLT(RolloverLeaseTerms):
        def _calculate_rent(self, term_config, rollover_date, global_settings):
            return 40.0 # Market rent for profile
    mock_market_terms = MockRLT(
        term_months=60, base_rent_value=None, unit_of_measure=UnitOfMeasureEnum.PER_UNIT,
        frequency=FrequencyEnum.ANNUAL, upon_expiration=UponExpirationEnum.MARKET
    )
    mock_profile = RolloverProfile(
        name="StdOfficeProfile", term_months=60, renewal_probability=0.0,
        downtime_months=3, market_terms=mock_market_terms, renewal_terms=mock_market_terms,
        option_terms=mock_market_terms
    )
    rollover_profiles = [mock_profile]
    profile_map = {mock_profile.name: mock_profile}
    # --- End Profile Setup --- #

    prop = Property(
        name="Test Property Input Only",
        property_type=AssetTypeEnum.OFFICE,
        net_rentable_area = sum(ls.area for ls in input_lease_specs),
        gross_area=sum(ls.area for ls in input_lease_specs) + 1000,
        rent_roll=rent_roll,
        rollover_profiles=rollover_profiles,
        losses=Losses(general_vacancy=GeneralVacancyLossConfig(rate=0.05)),
        expenses=None
    )

    analyzer = CashFlowAnalysis(
        property=prop,
        analysis_start_date=analysis_start,
        analysis_end_date=analysis_end,
        settings=settings,
        absorption_plans=None # No absorption plans
    )

    def mock_lookup(key):
        if isinstance(key, str) and key == mock_profile.name: return mock_profile
        if hasattr(prop, key): 
            val = getattr(prop, key) 
            if isinstance(val, (int, float, str, date)): return val
        raise LookupError(f"Mock lookup failed for key: {key}")
    analyzer._build_lookup_fn = lambda computed_results: mock_lookup

    # Act
    summary_df = analyzer.create_cash_flow_dataframe()

    # Assert
    assert isinstance(summary_df, pd.DataFrame)
    pgr_col = AggregateLineKey.POTENTIAL_GROSS_REVENUE.value
    downtime_col = AggregateLineKey.DOWNTIME_VACANCY_LOSS.value
    vac_col = AggregateLineKey.GENERAL_VACANCY_LOSS.value
    noi_col = AggregateLineKey.NET_OPERATING_INCOME.value

    rent_existing = 5000 * 30.0 / 12 # 12500
    rent_future = 6000 * 32.0 / 12   # 16000
    expected_downtime_monthly = rent_future # $16k

    # Check Jan 2025: Only Existing Tenant
    assert summary_df[pgr_col].loc[pd.Period("2025-01")] == pytest.approx(rent_existing)
    assert summary_df[downtime_col].loc[pd.Period("2025-01")] == pytest.approx(expected_downtime_monthly)
    gross_vac_jan25 = rent_existing * 0.05
    net_vac_jan25 = max(0, gross_vac_jan25 - expected_downtime_monthly)
    assert summary_df[vac_col].loc[pd.Period("2025-01")] == pytest.approx(net_vac_jan25)
    # NOI = PGR - Downtime - Gen Vac (assuming no other revenue/opex)
    expected_noi_jan25 = rent_existing - expected_downtime_monthly - net_vac_jan25
    assert summary_df[noi_col].loc[pd.Period("2025-01")] == pytest.approx(expected_noi_jan25)

    # Check Jul 2025: Existing + Future Tenant
    assert summary_df[pgr_col].loc[pd.Period("2025-07")] == pytest.approx(rent_existing + rent_future)
    assert summary_df[downtime_col].loc[pd.Period("2025-07")] == 0.0 # Future tenant started
    gross_vac_jul25 = (rent_existing + rent_future) * 0.05
    net_vac_jul25 = gross_vac_jul25 # No specific loss
    assert summary_df[vac_col].loc[pd.Period("2025-07")] == pytest.approx(net_vac_jul25)
    expected_noi_jul25 = (rent_existing + rent_future) - net_vac_jul25
    assert summary_df[noi_col].loc[pd.Period("2025-07")] == pytest.approx(expected_noi_jul25)


def test_cash_flow_analysis_absorption_only(global_settings_default):
    """Integration test for CashFlowAnalysis with only AbsorptionPlan."""
    # Arrange
    analysis_start = date(2025, 1, 1)
    analysis_end = date(2026, 12, 31)
    settings = global_settings_default

    vacant_suites = [
        VacantSuite(suite="VAC-1", floor="1", area=10000, use_type=ProgramUseEnum.OFFICE),
        VacantSuite(suite="VAC-2", floor="1", area=8000, use_type=ProgramUseEnum.OFFICE)
    ]
    rent_roll = RentRoll(leases=[], vacant_suites=vacant_suites) # No input leases
    
    # --- Reusable Rollover Profile Setup --- #
    class MockRLT(RolloverLeaseTerms):
        def _calculate_rent(self, term_config, rollover_date, global_settings):
            return 40.0 # Market rent for profile
    mock_market_terms = MockRLT(
        term_months=60, base_rent_value=None, unit_of_measure=UnitOfMeasureEnum.PER_UNIT,
        frequency=FrequencyEnum.ANNUAL, upon_expiration=UponExpirationEnum.MARKET
    )
    mock_profile = RolloverProfile(
        name="StdOfficeProfile", term_months=60, renewal_probability=0.0,
        downtime_months=3, market_terms=mock_market_terms, renewal_terms=mock_market_terms,
        option_terms=mock_market_terms
    )
    rollover_profiles = [mock_profile]
    profile_map = {mock_profile.name: mock_profile}
    # --- End Profile Setup --- #

    absorption_plan = AbsorptionPlan(
        name="MainOfficeAbsorption",
        space_filter=SpaceFilter(use_types=[ProgramUseEnum.OFFICE]),
        start_date_anchor=StartDateAnchorEnum.ANALYSIS_START,
        pace=FixedQuantityPace(quantity=1, unit="Units", frequency_months=1), # Lease 1 suite per month
        leasing_assumptions=mock_profile.name 
    )

    prop = Property(
        name="Test Property Absorb Only",
        property_type="Office",
        net_rentable_area = sum(vs.area for vs in vacant_suites),
        rent_roll=rent_roll,
        rollover_profiles=rollover_profiles,
        losses=Losses(general_vacancy=GeneralVacancyLossConfig(rate=0.05)) 
    )

    analyzer = CashFlowAnalysis(
        property=prop,
        analysis_start_date=analysis_start,
        analysis_end_date=analysis_end,
        settings=settings,
        absorption_plans=[absorption_plan] # Only absorption plan
    )

    def mock_lookup(key):
        if isinstance(key, str) and key == mock_profile.name: return mock_profile
        if hasattr(prop, key):
            val = getattr(prop, key)
            if isinstance(val, (int, float, str, date)): return val
        raise LookupError(f"Mock lookup failed for key: {key}")
    analyzer._build_lookup_fn = lambda computed_results: mock_lookup

    # Act
    summary_df = analyzer.create_cash_flow_dataframe()

    # Assert
    assert isinstance(summary_df, pd.DataFrame)
    pgr_col = AggregateLineKey.POTENTIAL_GROSS_REVENUE.value
    downtime_col = AggregateLineKey.DOWNTIME_VACANCY_LOSS.value
    vac_col = AggregateLineKey.GENERAL_VACANCY_LOSS.value
    noi_col = AggregateLineKey.NET_OPERATING_INCOME.value

    rent_absorbed1 = 10000 * 40.0 / 12 # 33333.33 (VAC-1)
    rent_absorbed2 = 8000 * 40.0 / 12  # 26666.67 (VAC-2)

    # Check Jan 2025: First suite (VAC-1) absorbed
    assert summary_df[pgr_col].loc[pd.Period("2025-01")] == pytest.approx(rent_absorbed1)
    assert summary_df[downtime_col].loc[pd.Period("2025-01")] == 0.0 # No input future leases
    gross_vac_jan25 = rent_absorbed1 * 0.05
    assert summary_df[vac_col].loc[pd.Period("2025-01")] == pytest.approx(gross_vac_jan25)
    expected_noi_jan25 = rent_absorbed1 - gross_vac_jan25
    assert summary_df[noi_col].loc[pd.Period("2025-01")] == pytest.approx(expected_noi_jan25)

    # Check Feb 2025: Second suite (VAC-2) also absorbed
    assert summary_df[pgr_col].loc[pd.Period("2025-02")] == pytest.approx(rent_absorbed1 + rent_absorbed2)
    assert summary_df[downtime_col].loc[pd.Period("2025-02")] == 0.0
    gross_vac_feb25 = (rent_absorbed1 + rent_absorbed2) * 0.05
    assert summary_df[vac_col].loc[pd.Period("2025-02")] == pytest.approx(gross_vac_feb25)
    expected_noi_feb25 = (rent_absorbed1 + rent_absorbed2) - gross_vac_feb25
    assert summary_df[noi_col].loc[pd.Period("2025-02")] == pytest.approx(expected_noi_feb25)


# @pytest.mark.skip(reason="Need fixtures and detailed implementation")
# def test_generate_lease_specs_start_date_anchor():
# ... existing code ...

@pytest.fixture
def vacant_suites_basic():
    """Provides a basic list of vacant suites."""
    return [
        VacantSuite(suite="101", floor="1", area=12000, use_type=ProgramUseEnum.OFFICE),
        VacantSuite(suite="102", floor="1", area=8000, use_type=ProgramUseEnum.OFFICE),
        VacantSuite(suite="201", floor="2", area=5000, use_type=ProgramUseEnum.OFFICE),
        VacantSuite(suite="202", floor="2", area=7000, use_type=ProgramUseEnum.OFFICE),
    ]

@pytest.fixture
def direct_terms_simple():
    """Provides simple DirectLeaseTerms."""
    return DirectLeaseTerms(
        term_months=60,
        base_rent_value=25.00,
        base_rent_unit_of_measure=UnitOfMeasureEnum.PER_UNIT,
        upon_expiration=UponExpirationEnum.MARKET,
    )

@pytest.fixture
def global_settings_default():
    """Provides default GlobalSettings."""
    return GlobalSettings()

def create_mock_lookup_fn(profile_map: dict):
    """Creates a simple mock lookup function for testing."""
    def mock_lookup(identifier):
        if identifier in profile_map:
            return profile_map[identifier]
        raise LookupError(f"Identifier '{identifier}' not found in mock map.")
    return mock_lookup 