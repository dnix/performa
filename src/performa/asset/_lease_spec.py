from __future__ import annotations

from datetime import date
from typing import Literal, Optional

import pandas as pd
from pydantic import computed_field, model_validator

from ..core._enums import (
    FrequencyEnum,
    LeaseTypeEnum,
    ProgramUseEnum,
    UnitOfMeasureEnum,
    UponExpirationEnum,
)
from ..core._model import Model
from ..core._types import PositiveFloat, PositiveInt
from ._lc import LeasingCommission
from ._recovery import RecoveryMethod
from ._rent_abatement import RentAbatement
from ._rent_escalation import RentEscalation
from ._ti import TenantImprovementAllowance


class LeaseSpec(Model):
    """
    Defines the parameters of a lease term before cash flow projection.
    Used as input or generated by AbsorptionPlan.
    Maximizes reuse of existing component models.

    **Convention for Initial Vacancy**:
    Space that is vacant at the analysis start but expected to lease later
    (i.e., initial downtime vacancy) is represented by creating a `LeaseSpec`
    with `source='Input'` and a `start_date` set to the future expected
    lease commencement date. This `LeaseSpec` is derived from a `Lease`
    object provided in the input `RentRoll.leases` list.
    The period between analysis start and `start_date` constitutes the downtime.
    """

    tenant_name: str  # Generated name for absorption leases
    suite: str
    floor: str
    area: PositiveFloat
    use_type: ProgramUseEnum
    lease_type: LeaseTypeEnum

    # Timeline
    start_date: date
    end_date: Optional[date] = None
    term_months: Optional[PositiveInt] = None

    # Initial Economics
    base_rent_value: PositiveFloat
    base_rent_unit_of_measure: UnitOfMeasureEnum
    base_rent_frequency: FrequencyEnum = FrequencyEnum.MONTHLY
    rent_escalation: Optional[RentEscalation] = None
    rent_abatement: Optional[RentAbatement] = None

    # Recoveries
    recovery_method: Optional[RecoveryMethod] = None

    # Lease Costs
    ti_allowance: Optional[TenantImprovementAllowance] = None
    leasing_commission: Optional[LeasingCommission] = None

    # Rollover
    upon_expiration: UponExpirationEnum
    rollover_profile_ref: Optional[str] = None

    # Metadata
    source: Literal["Input", "AbsorptionPlan"]

    @model_validator(mode="after")
    def check_term(self) -> "LeaseSpec":
        if self.end_date is None and self.term_months is None:
            raise ValueError("Either end_date or term_months must be provided")
        if self.end_date and self.term_months:
            pass
        if self.end_date and self.end_date <= self.start_date:
            raise ValueError("end_date must be after start_date")
        return self

    @computed_field
    @property
    def computed_end_date(self) -> date:
        if self.end_date:
            return self.end_date
        if self.term_months:
            return (
                pd.Period(self.start_date, freq="M") + self.term_months - 1
            ).end_time.date()
        raise ValueError("Cannot compute end_date without end_date or term_months")

    @computed_field
    @property
    def computed_term_months(self) -> int:
        if self.term_months:
            return self.term_months
        if self.end_date:
            periods = pd.period_range(
                start=self.start_date, end=self.end_date, freq="M"
            )
            return len(periods)
        raise ValueError("Cannot compute term_months without end_date or term_months")
